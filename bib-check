#!/usr/bin/env python3
"""Usage: {} BIBFILE

Check the 'localfile' keys of the BibTeX entries in BIBFILE against the
contents of the current directory.
"""
from collections import OrderedDict
from os import listdir
from os.path import exists, isdir
import re
import sys


ignore = set([
    '.git',
    '.gitignore',
    'README',
    ])


ENTRY = """@{}{{{},
\t{}
}}

"""


def read_database(f):
    """Read BibTeX entries from file *f*.

    Assumes entries are separated by blank lines, and there are no blank lines
    within entries. Returns a collections.OrderedDict, in which all BibTeX
    entries are stored as strings under their BibTeX keys, and other non-entry
    content of *f* is preserved in order.
    """
    entries = OrderedDict()
    # RegEx for the start of an entry
    re1 = re.compile("@([^{]*){([^,]*),\n")
    re2 = re.compile("\t([^\s]*) = (.*),?\n")
    # state:
    # - None: the next line is start of a new entry, or non-entry BibTeX code
    #   like a @comment
    # - any other value: either the key of an entry, or the first line of non-
    #   entry code in a non-entry block
    current = None
    extra = 0
    for line in f:  # process the file linewise
        if current is None:  # next line might be the start of a new entry
            key = re1.match(line)
            if key:  # it is
                current = key.groups()[1]
                entries[current] = OrderedDict(__type=key.groups()[0])
            else:
                entries[extra] = line
                extra += 1
        elif line == '\n':  # a blank line; we're between entries or other code
            current = None
        else:  # currently reading an entry
            fn = re2.match(line)
            if fn:
                entries[current][fn.groups()[0]] = fn.groups()[1].rstrip(',')
    return entries


def write_database(f, db):
    for key, entry in db.items():
        if isinstance(key, int):
            f.write(entry)
            continue
        t = entry.pop('__type')
        f.write(ENTRY.format(t, key, ',\n\t'.join(['{} = {}'.format(k, v) for
                                                    k, v in entry.items()])))


if __name__ == '__main__':
    # input
    try:
        libfile = sys.argv[1]
        ignore.add(libfile)
        bib = read_database(open(libfile, 'r'))
    except IndexError:
        print(__doc__.format(sys.argv[0]))
        sys.exit(1)
    # get the set of files in the current directory
    files = set(filter(lambda x: not isdir(x),
              listdir('.'))).difference(ignore)
    # check the files
    nofile = []
    missing = []
    for key, fn in bib.items():
        if isinstance(key, int):
            continue
        try:
            if fn['localfile'] in files:
                files.remove(fn)
            else:
                missing.append('{} â†’ {}'.format(key, fn))
        except KeyError:
            nofile.append(key)
    # output
    print('Checking {}'.format(libfile),
        '{} entries with a localfile key'.format(len(bib)),
        '{} missing files:'.format(len(missing)),
        '\t' + '\n\t'.join(sorted(missing)),
        '{} entries without files:'.format(len(nofile)),
        '\t' + '\n\t'.join(sorted(nofile)),
        '{} files not listed in any entry:'.format(len(files)),
        '\t' + '\n\t'.join(sorted(files)), sep='\n')
    ## debug: Try to write the file again
    #write_database(open('test.bib', 'w'), bib)
