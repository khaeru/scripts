#!/usr/bin/env python3
"""Process data exported from the CEIC database
USAGE: ceic.py [FILE]...

The CEIC desktop client software exports to Microsoft Excel, data files are in
.xslx format. They may be converted to CSV with either:

    libreoffice --headless --convert-to ods --outdir csv Book??.xlsx
    ssconvert --export-file-per-sheet Book02.xlsx csv/02-%n.csv  # repeatedly

…and then renamed.


INPUT FILE FORMAT

- One series per column, except the first column of each file, which contains
  labels.
- The first eleven labels are for series information:

   0. [Series Name] — the CEIC desktop client puts the text "Select this link
      and click Refresh/Edit Download to update data and add or remove series"
      in the first row/column of the file. Most (not all) series names begin
      with 'CN: '.
   1. Country — always 'China'.
   2. Frequency — Monthly, Quarterly ("ending Mar, Jun, Sep, Dec") or Annual
      ("ending Dec of each year").
   3. Unit — 22 different values, in which:
      - 'th' → 10³
      - 'mn' → 10⁶
      - 'bn' → 10⁹
   4. Source — 294 different values.
   5. Status — either 'Active' or 'Discontinued'.
   6. Series Code — unique per series. A numeric and an alphabetical code, e.g.
      '12544001 (CTAIBC)'.
   7. Function Information — always empty ('').
   8. First Obs. Date — a mix of:
      - '0001' or '1/0001' (presumably NULL)
      - Years, e.g. '2012'
      - Months, e.g. '12/1998'
      - Dates, e.g. '2012-12-01', in which the day digits are always 01
   9. Last Obs. Date — as above. '0001' does not occur, but '1/0001' does.
  10. Last Update time — a mix of:
      - '1/1/0001' (presumably NULL)
      - Dates, either '3/1/2013' or '2008-11-28'

- Subsequent row labels are dates for the observations (data points) in the
  series. Every that appears as a row label corresponds to an observation in at
  least one of the series in the file; but any given series may not have an
  observation corresponding to every date that appears as a row label in its
  file. Dates are in a mix of the following formats:
  - Years, e.g. '1995'
  - Months, e.g. '8/2001'
  - Dates, e.g. '2003-02-01', in which the day digits are always 01


FREQUENCY

For series with 'Annual' frequency, the date is given as either 2003, or
2003-12, or 2003-12-01, in each case meaning 2003.

For series with 'Quarterly' frequency, the month is either 03, 06, 09, or 12,
and the day is either 01 or not given.

For series with 'Monthly' frequency, the date is given as either 2003-10 or
2003-10-01.
"""
import csv
from os import linesep
from os.path import isfile
import re
import sys


# header rows in data files
HEADERS = (
    'name',
    'country',
    'frequency',
    'unit',
    'source',
    'status',
    'series code',
    'function info',
    'first obs',
    'last obs',
    'updated',
    )
# Regexes used in `clean_data()`
_clean_re = {
    'series code': re.compile('(\d+) \(([A-Z]+)\)'),
    }
# Regexes for date formats used in `date_munge()`
_munge = tuple([re.compile(exp) for exp in [
    '((1/)?1/)?0001',
    '(?P<year>\d{4})(\.0)?$',
    '(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})',
    '((?P<day>\d{1,2})/)?(?P<month>\d{1,2})/(?P<year>\d{4})',
    ]])


def clean_data(s):
    """Tidy up data for series *s*.

    *s* is in the format generated by `read_data()`: a dict with the keys
    'info' and 'obs'. s['info'] is a dict with keys from `HEADERS`; s['obs'] is
    a dict with keys that are date tuples and values that are floats.
    """
    # Tokenize the name into a tuple
    name = s['info']['name'].split(': ')
    try:  # Remove an initial 'CN'
        name.remove('CN')
    except ValueError:
        pass
    s['info']['name'] = tuple(name)
    # Convert the series code into a tuple
    sc = _clean_re['series code'].match(s['info']['series code']).groups()
    s['info']['series code'] = (int(sc[0]), sc[1])
    # Rationalize first, last and update dates
    for i in ('first obs', 'last obs', 'updated'):
        s['info'][i] = date_munge(s['info'][i])
    # Clean up date tuples for obsevations
    if 'Annual' in s['info']['frequency']:
        # Strip -12-00 or -12-01 from dates
        for k in sorted(s['obs'].keys()):
            if k[1:] == (12, 0) or k[1:] == (12, 1):
                s['obs'][(k[0], 0, 0)] = s['obs'].pop(k)
    elif 'Quarterly' in s['info']['frequency'] or ('Monthly' in
                                                   s['info']['frequency']):
        # Strip -01 from dates
        for k in sorted(s['obs'].keys()):
            if k[2] == 1:
                s['obs'][(k[0], k[1], 0)] = s['obs'].pop(k)
    else:
        raise ValueError('Unrecognized frequency: {} for series {}'.format(
            s['info'][2], s['info'][0]))


def read_data(files, clean=True):
    """Read CEIC data from *files*

    """
    data = []  # Each entry is one data series
    # One set for each header, plus one for observation dates
    info = dict.fromkeys(HEADERS, set())
    count = 0  # Number of observations read
    for fn in files:  # Loop over input files
        with open(fn) as f:
            d0 = len(data)  # Index in `data` of the first series in this file
            dates = []  # Observation dates in this file
            for row_num, row in enumerate(csv.reader(f)):  # Loop over rows
                # Process the first column
                if row_num == 0:  # First row
                    # Extend the data list to accommodate the series (columns)
                    # in this file
                    data.extend([dict(info=dict.fromkeys(HEADERS), obs={}) for
                                i in range(len(row) - 1)])
                # First column of the file has no data, only labels
                label = row.pop(0)
                if row_num >= len(HEADERS):
                    # After len(HEADERS), labels are dates for the observations
                    # and differ from file to file. Store these for later use.
                    dates.append(date_munge(label))
                # Process the series (remaining columns)
                for col, entry in enumerate(row):
                    if row_num < len(HEADERS):
                        # First entries in each column are series information
                        info[HEADERS[row_num]].add(entry)
                        data[d0+col]['info'][HEADERS[row_num]] = entry
                    else:  # Subsequent entries are observations
                        try:  # Convert str → float
                            entry = float(entry)
                            count += 1
                        except ValueError as e:
                            if entry == '':  # Empty entry → no data
                                continue
                            # Non-float, non-empty entry
                            print(entry)
                            raise e
                        # Save the observation
                        data[d0+col]['obs'][dates[-1]] = entry
        if clean:
            for s in data[d0:]:
                clean_data(s)
    return data, count, info


def date_munge(raw):
    """Turn *raw* into a date tuple.

    *raw* is a string in any of the formats in _munge. The date tuple returned
    has three entries: year, month and day. If *raw* is in a format that does
    not specify a month or day, the corresponding tuple entry is 0.
    """
    for exp in _munge:
        # str is necessary because csv.reader converts years ("2001") to float
        match = exp.match(str(raw))
        if match:
            d = match.groupdict(0)
            result = [d.get('year', 0), d.get('month', 0), d.get('day', 0)]
            return tuple(map(int, result))
    raise ValueError("Unrecognized date: '{}'".format(raw))


date_str = lambda raw: '{:04}-{:02}-{:02}'.format(*raw).split('-00')[0]


if __name__ == '__main__':
    # read the data
    files = sys.argv[1:]
    assert len(files) > 0 and all(map(isfile, files))
    data, count, info = read_data(files)
    dates = set()
    for series in data:
        dates.update(set(series['obs'].keys()))

    # dump to a single CSV file in roughly the same format, series in rows
    with open('out.csv', 'w') as f:
        w = csv.writer(f, delimiter='\t', lineterminator=linesep)
        w.writerow(list(HEADERS) + sorted(map(date_str, dates)))
        for series in data:
            w.writerow(list([series['info'][k] for k in HEADERS[:-3]]) + list(
                       [date_str(series['info'][k]) for k in HEADERS[-3:]]) +
                       list([series['obs'].get(d) for d in sorted(dates)]))

    # Construct a tree of the series names
    def print_tree(parent, level=0):
        f.write('{}\n'.format(parent[None]) if None in parent else '\n')
        for k in sorted(filter(None, parent.keys())):
            f.write('{:<37}'.format(' ' * level * 2 + k))
            print_tree(parent[k], level+1)

    def tree_add(parent, path, data):
        if len(path) == 0:
            parent[None] = data
            return
        elif path[0] not in parent:
            parent[path[0]] = {}
        tree_add(parent[path[0]], path[1:], data)

    tree = {}
    for series in data:
        tree_add(tree, series['info']['name'], series['info']['series code'][1]
                 + ': ' + ': '.join(series['info']['name']))
    with open('tree.txt', 'w') as f:
        print_tree(tree)
